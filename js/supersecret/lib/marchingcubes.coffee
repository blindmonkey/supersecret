definitions = [
  [[true, true, true, true, true, true, true, true], []]
  [[false, false, false, false, false, false, false, false], []]
  [[true, false, false, false, false, false, false, false], [
    [[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]]
  ]]
  [[true, true, true, true, false, false, false, false], [
    [[0.5, 0, 0], [0.5, 1, 0], [0.5, 1, 1]]
    [[0.5, 0, 0], [0.5, 1, 1], [0.5, 0, 1]]
  ]]
  [[true, true, false, false, false, false, false, false], [
    [[0.5, 0, 0], [0, 0.5, 1], [0.5, 0, 1]]
    [[0.5, 0, 0], [0, 0.5, 0], [0, 0.5, 1]]
  ]]
  [[false, false, true, true, true, true, true, true], [
    [[0.5, 0, 0], [0.5, 0, 1], [0, 0.5, 1]]
    [[0.5, 0, 0], [0, 0.5, 1], [0, 0.5, 0]]
  ]]
  [[true, true, true, false, true, false, false, false], [
    [[0.5, 1, 0], [1, 0, 0.5], [1, 0.5, 0]]
    [[0.5, 1, 0], [0.5, 0, 1], [1, 0, 0.5]]
    [[0.5, 1, 0], [0, 0.5, 1], [0.5, 0, 1]]
    [[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 1]]
  ]]
  [[true, true, true, false, false, false, false, false], [
   [[0.5, 0, 0], [0.5, 1, 0], [0.5, 0, 1]]
   [[0.5, 0, 1], [0, 1, 0.5], [0, 0.5, 1]]
   [[0.5, 0, 1], [0.5, 1, 0], [0, 1, 0.5]]
  ]]
  [[true, true, false, false, false, false, true, true], [
    [[0, 0.5, 0], [0, 0.5, 1], [0.5, 1, 1]]
    [[0, 0.5, 0], [0.5, 1, 1], [0.5, 1, 0]]
    [[0.5, 0, 0], [1, 0.5, 1], [0.5, 0, 1]]
    [[0.5, 0, 0], [1, 0.5, 0], [1, 0.5, 1]]
  ]]
  [[true, false, false, false, false, false, true, false], [
    [[0, 0, 0.5], [1, 1, 0.5], [0.5, 1, 0]]
    [[0, 0, 0.5], [0.5, 1, 0], [0, 0.5, 0]]
    [[0, 0, 0.5], [0.5, 0, 0], [1, 0.5, 0]]
    [[0, 0, 0.5], [1, 0.5, 0], [1, 1, 0.5]]
  ]]
  [[false, false, false, true, false, true, true, false], [
    [[0.5, 1, 1], [1, 0.5, 1], [1, 1, 0.5]]
    [[0, 1, 0.5], [0.5, 0, 1], [0, 0.5, 1]]
    [[0, 1, 0.5], [1, 0, 0.5], [0.5, 0, 1]]
    [[0, 1, 0.5], [1, 0.5, 0], [1, 0, 0.5]]
    [[0, 1, 0.5], [0.5, 1, 0], [1, 0.5, 0]]
  ]]
  [[true, false, false, false, false, false, false, true], [
    [[0, 0, 0.5], [1, 0.5, 1], [0.5, 1, 1]]
    [[0, 0, 0.5], [0.5, 1, 1], [0, 0.5, 0]]
    [[0, 0.5, 0], [0.5, 1, 1], [1, 1, 0.5]]
    [[0, 0.5, 0], [1, 1, 0.5], [0.5, 0, 0]]
    [[0.5, 0, 0], [1, 1, 0.5], [1, 0.5, 1]]
    [[0.5, 0, 0], [1, 0.5, 1], [0, 0, 0.5]]
  ]]
  [[true, true, false, false, false, false, true, false], [
    [[0, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]]
    [[0, 0.5, 0], [0, 0.5, 1], [1, 1, 0.5]]
    [[0, 0.5, 1], [0.5, 0, 1], [1, 1, 0.5]]
    [[0.5, 0, 1], [0.5, 0, 0], [1, 0.5, 0]]
    [[0.5, 0, 1], [1, 0.5, 0], [1, 1, 0.5]]
  ]]
  [[true, false, false, false, false, true, true, true], [
    [[1, 0.5, 0], [1, 0, 0.5], [0.5, 0, 0]]
    [[0, 0.5, 0], [0, 0, 0.5], [0.5, 0, 1]]
    [[0, 0.5, 0], [0.5, 0, 1], [0.5, 1, 1]]
    [[0, 0.5, 0], [0.5, 1, 1], [0.5, 1, 0]]
  ]]
  [[true, false, false, false, true, true, false, true], [
    [[1, 0.5, 0], [0, 0.5, 0], [0, 0, 0.5]]
    [[1, 0.5, 0], [0, 0, 0.5], [0.5, 0, 1]]
    [[1, 0.5, 0], [0.5, 0, 1], [0.5, 1, 1]]
    [[1, 0.5, 0], [0.5, 1, 1], [1, 1, 0.5]]
  ]]
  [[true, false, false, false, true, false, true, true], [
    [[0, 0, 0.5], [1, 0, 0.5], [0, 0.5, 0]]
    [[0, 0.5, 0], [1, 0, 0.5], [0.5, 1, 0]]
    [[0.5, 1, 0], [1, 0, 0.5], [0.5, 1, 1]]
    [[1, 0, 0.5], [1, 0.5, 1], [0.5, 1, 1]]
  ]]
  [[true, true, true, true, true, false, false, false], [
    [[0.5, 1, 1], [0.5, 0, 1], [1, 0, 0.5]]
    [[0.5, 1, 1], [1, 0, 0.5], [1, 0.5, 0]]
    [[0.5, 1, 1], [1, 0.5, 0], [0.5, 1, 0]]
  ]]
  [[true, false, true, true, true, true, false, false], [
    [[0, 0.5, 1], [0, 0, 0.5], [0.5, 0, 1]]
    [[0.5, 1, 1], [1, 0.5, 1], [1, 0.5, 0]]
    [[0.5, 1, 1], [1, 0.5, 0], [0.5, 1, 0]]
  ]]
  [[true, false, false, true, false, true, true, false], [
    [[0.5, 1, 1], [1, 0.5, 1], [1, 1, 0.5]]
    [[0, 1, 0.5], [0.5, 1, 0], [0, 0.5, 0]]
    [[0, 0.5, 1], [0, 0, 0.5], [0.5, 0, 1]]
    [[1, 0, 0.5], [0.5, 0, 0], [1, 0.5, 0]]
  ]]
  [[true, false, false, true, false, true, true, true], [
    [[0, 1, 0.5], [0.5, 1, 0], [0, 0.5, 0]]
    [[1, 0.5, 0], [1, 0, 0.5], [0.5, 0, 0]]
    [[0, 0.5, 1], [0, 0, 0.5], [0.5, 0, 1]]
  ]]
  [[true, false, false, true, true, true, true, true], [
    [[0, 0.5, 1], [0, 0, 0.5], [0.5, 0, 1]]
    [[0, 1, 0.5], [0.5, 1, 0], [0, 0.5, 0]]
  ]]
  [[true, false, true, true, true, true, false, true], [
    [[0, 0.5, 1], [0, 0, 0.5], [0.5, 0, 1]]
    [[0.5, 1, 0], [1, 1, 0.5], [1, 0.5, 0]]
  ]]
  [[true, true, true, true, true, true, true, false], [
    [[0.5, 1, 1], [1, 0.5, 1], [1, 1, 0.5]]
  ]]
]

getCoordFromIndex = (index) ->
  z = index % 2
  y = (index - z) / 2 % 2
  x = ((index - z) / 2 - y) / 2 % 2
  return [x, y, z]

getIndexFromCoord = (x, y, z) ->
  return x * 4 + y * 2 + z

transformCorners = (transform, corners) ->
  newCorners = []
  for i in [0..corners.length - 1]
    coord = getCoordFromIndex(i)
    coord = transform(coord...)
    index = getIndexFromCoord(coord...)
    newCorners[index] = corners[i]
  return newCorners

arrayToNumber = (a) ->
  # [true, false, true] -> 5
  n = 0
  for i in [0..a.length - 1]
    if a[i]
      e = a.length - i - 1
      n += Math.pow(2, e)
  return n
numberToArray = (n) ->
  a = []
  while n > 0
    r = n % 2
    v = false
    if r > 0
      n -= r
      v = true
    a.splice(0, 0, v)
    n /= 2
  while a.length < 8
    a.splice(0, 0, false)
  return a

table = null

initializeTable = ->
  rotateRightX = (x, y, z) -> [x, 1-z, y]
  rotateLeftX = (x, y, z) -> [x, z, 1-y]
  rotateRightY = (x, y, z) -> [1-z, y, x]
  rotateLeftY = (x, y, z) -> [z, y, 1-x]
  rotateRightZ = (x, y, z) -> [1-y, x, z]
  rotateLeftZ = (x, y, z) -> [y, 1-x, z]

  combineTransforms = (transforms...) ->
    return (x, y, z) ->
      for transform in transforms
        [x, y, z] = transform(x, y, z)
      return [x, y, z]

  baseTransforms = [
    rotateLeftX,
    rotateRightX,
    rotateLeftY,
    rotateRightY,
    rotateLeftZ,
    rotateRightZ,
  ]
  transforms = []
  for i in baseTransforms
    transforms.push i
    for j in baseTransforms
      transforms.push combineTransforms(i, j)
      for k in baseTransforms
        transforms.push combineTransforms(i, j, k)
  transforms.push combineTransforms(rotateRightX, rotateRightY, rotateRightY)

  table = {}
  c = 0
  for [definition, polygons] in definitions
    #n = arrayToNumber(definition)
    for transform in transforms
      corners = transformCorners(transform, definition)
      n = arrayToNumber(corners)
      if n not of table
        c++
        table[n] = [polygons, transform]
  console.log(table)

getCornerArray = (getter, coords...) ->
  [x, y, z] = coords
  return [
    getter(x, y, z)
    getter(x, y, z + 1)
    getter(x, y + 1, z)
    getter(x, y + 1, z + 1)
    getter(x + 1, y, z)
    getter(x + 1, y, z + 1)
    getter(x + 1, y + 1, z)
    getter(x + 1, y + 1, z + 1)
  ]


lib.export('MarchingCubes', class MarchingCubes
  constructor: (size, scale) ->
    if not table?
      initializeTable()
    dirty = true
    @scale = scale
    @identified = 0
    @remaning = 0
    @grid = new Grid(3, size)
    #geometry = new THREE.Geometry()
    @faceManager = new FaceManager(500)

  getGeometry: ->
    return @faceManager.geometry

  updateCube: (getter, x, y, z) ->
    originalCorners = getCornerArray(getter, x, y, z)
    for c in originalCorners
      if c is undefined
        a = @grid.get(x, y, z)
        if a
          console.log("Removing all faces because this cube is undefined")
          faces = ({a:f[0], b:f[1], c:f[2]} for f in a)
          @faceManager.removeFaces(faces...)
        return

    polygons = null
    transform = null
    n = arrayToNumber(originalCorners)
    if n of table
      [polygons, transform] = table[n]

    if polygons?
      @identified++
      a = @grid.get(x, y, z)
      if a
        faces = ({a:f[0], b:f[1], c:f[2]} for f in a)
        #console.log('Removing faces', faces)
        @faceManager.removeFaces(faces...)
      a = []
      for face in polygons
        transformedFace = @getTransformedFace(transform, face, [x * @scale, y * @scale, z * @scale])
        a.push(transformedFace)
        #console.log('Adding new face', transformedFace)
        @faceManager.addFace(transformedFace.concat([{color: new THREE.Color(0xff0000)}])...)
      @grid.set(a, x, y, z)
    else
      @remaining++

    return @faceManager.geometry

  getTransformedFace: (transform, face, offset) ->
    [ox, oy, oz] = offset
    newFace = []
    for [x, y, z] in face
      [nx, ny, nz] = transform(x, y, z)
      newFace.push [nx * @scale + ox, ny * @scale + oy, nz * @scale + oz]
    return newFace

  generateGeometry: (getter, ranges...) ->
    console.log(ranges)
    identified = 0
    remaining = 0

    @grid = new Grid(3, ranges)
    #geometry = new THREE.Geometry()
    @faceManager = new FaceManager(1000)
    console.log('generating geometry')
    for x in [ranges[0][0]..ranges[0][1]]
      #console.log(x / grid.size[0] * 100)
      for y in [ranges[1][0]..ranges[1][1]]
        for z in [ranges[2][0]..ranges[2][1]]
          @updateCube(getter, x, y, z)

    console.log 'faces computed ' + identified + '/' + remaining
    g = @faceManager.generateGeometry()
    console.log 'geometry generated'
    return g
)
